Section 1.1.3
1. an assembler creates machine language files from source assembly files
   a linker combines multiple machine language files into one executable program
   combining these two, one can create programs from this flow
   (asm) multiple sources -> multiple sources in machine language -> one large program 
3. a single statement in C++ equates to many statements in machine language.
   there is a lot of features in high level languages that helps with portability, security and type safety.
8. C++/C has much more stricter type checking rules - compilers give errors or warnings about inconsistent data types. in assembly there is none of those and therefore it does not care.
12. X = (Y * 4) + 3;
mov eax,Y
mov ebx,4
imul ebx
add eax,3
mov X,eax

Section 1.2.1
2. in an interpreted program two things happens in every statement:
	a decode
	and an execution of the decoded statement
   in a translated program one thing happens only:
   	the execution of the decoded statement
3. true
10. ISA

Section 1.3.9
2. 
(1 * 2^7) + (1 * 2^6) + (1 * 2^5) + (1 * 2^4) + (1 * 2^3) = 248
(1 * 2^7) + (1 * 2^6) + (1 * 2^3) + (1 * 2^1) = 202
(1 * 2^7) + (1 * 2^6) + (1 * 2^5) + (1 * 2^4) = 240
3.
   00001111
 + 00000010
 = 00010001
     11010101 
 +   01101011
 =  101000000
   00001111 
 + 00001111
 = 00001110
5. 
   ceiling(log_2 65) = 7
   ceiling(log_2 409) = 9
   ceiling(log_2 16385) = 15
6. to hex
   0011 0101 1101 1010
   35DA
   1100 1110 1010 0011
   CEA3
   1111 1110 1101 1011
   FEDB
7. to bin
   A4693FBC
   1010 0100 0110 1001 0011 1111 1011 1100
   B697C7A1
   1011 0110 1001 0111 1100 0111 1010 0001
   2B3D9461
   0010 1011 0011 1101 1001 0100 0110 0001

1.7.1 
1. left most digit
2. to dec
  00110101
  = (1 * 2^5) + (1 * 2^4) + (1 * 2^2) + (1 * 2^0) = 53
  10010110
  = (1 * 2^7) + (1 * 2^5) + (1 * 2^2) + (1 * 2^1) = 166
  11001100
  = (1 * 2^7) + (1 * 2^6) + (1 * 2^3) + (1 * 2^2) = 204
3.
    010101111
  + 011011011
  = 110001010
 
    010010111 
  + 011111111
  = 110010110
 
    001110101 
  + 010101100
  = 100100001
4. 
    00001101
  - 00000111
  = 00000110
5. how many bits
 a. word 16
 b. doubleword 32
 c. quadword 64
 d. double quadword 128

6. 
   ceiling(log_2 4095) 12
   ceiling(log_2 65534) 16
   ceiling(log_2 32419) 15
7. to hex
   0011 0101 1101 1010
   35DA
   1100 1110 1010 0011
   CEA3
   1111 1110 1101 1011
   FEDB
8. to bin
   0126F9D4
   1001001101111100111010100
   6ACDFA95
   1101010110011011111101010010101
   F69BDC2A
   11110110100110111101110000101010
9. to unsigned dec
   3A
   (3 * 16^1) + (10 * 16^0) = 58
   1BF
   (1 * 16^2) + (11 * 16^1) + (15 * 16^0) = 447
   1001
   (1 * 16^3) + (1 * 16^0) = 4097

10. to unsigned dec
   62
   (6 * 16^1) + (2 * 16^0) = 98
   4B3
   (4 * 16^2) + (11 * 16^1) + (3 * 16^0) = 1203
   29F
   (2 * 16^2) + (9 * 16^2) + (15 * 16^0) = 671
11. to hex
	-24
	hex(24) = 18 
	reversed -> E7
	E7 + 1 = E8
	
	-331
	hex(331) = 14B
	reversed -> EB4
	EB4 + 1 = EB5
	331 / 16 = 20 B
	20 / 16 = 1 4
	1 / 16 = 0 1
12. to hex
   -21
   hex(21) = 15
   reversed -> EA
   EB
   -45
   hex(45) = 2D
   reversed -> D2
   d#
13. signed hex to dec
	6BF9
	(6 * 16^3) + (11 * 16^2) + (15 * 16^1) + (9 * 16^0) = 27641
	C123
	reversed -> 3EDC
	3EDD
	
	(3 * 16^3) + (14 * 16^2) + (13 * 16^1) + (13 * 16^0) = 16093
14. signed hex to dec
    4CD2
	(4 * 16^3) + (12 * 16^2) + (13 * 16^1) + (2 * 16^0) = 19666
    8230
	7DB0
	(7 * 16^3) + (13 * 16^2) + (11 * 16^1) = 32176
15. signed bin to dec
	10110101
	reversed -> 01001010
		01001011
	(1 + 2^6) + (1 + 2^0) + (1 + 2^1) + (1 + 2^3) = 79
	
	00101010
	(1 + 2^1) + (1 * 2^3) + (1 * 2^5) = 43
	
	11110000
	
	reversed -> 00001111
		00010000
	(1 * 2^4)
16. dec of signed bin
	10000000
	reversed -> 01111111
		11111110
	(1 * 2^7) + (1 * 2^6) + (1 * 2^5) + (1 * 2^4) + (1 * 2^3) + (1 * 2^2) + (1 * 2^1) = 254
	11001100
	reversed -> 00110011
		00110111
	(1 * 2^0) + (1 * 2^1) + (1 * 2^2) + (1 * 2^4) + (1 * 2^5) = 55
	10110111
17. to two complement bin
   -5
   bin(5) = 00000101
		11111010
		11111011
   
   -42
   bin(42) = 00101010
		11010101
		11010110
	
   -16
    bin(16) = 00010000
		11101111
		11111110
		
18. to two complement bin
   -72
   bin(72) = 01001000
		10110111
		10111111
   -98
   bin(98) = 01100010
		10011101
		10011111
   -26
   bin(26) = 00011010
		11100101
		11100110
19. 
    6B4 + 3FE
	AB2
	
    A49 + 6BD
	1106
20.
    7C4 + 3BE
	B82
    B69 + 7AD
	1316
21. hex and dec representations
    ASCII B
    42 & 66
22. hex and dex representations
	ASCII G
	47 & 71
	
25. not(A OR B)
	A B (A OR B) not(A OR B)
	T T    T         F
	T F    T         F
	F T    T         F
	F F    F         T

Section 1.4.2
1. NOT(X) or Y
2. X AND Y
3. (T AND F) OR T = T
4. NOT(F or T) = F
5. NOT F or NOT T = T